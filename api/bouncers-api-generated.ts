/* tslint:disable */
/* eslint-disable */
/*
Swagger CrowdSec

CrowdSec local API

The version of the OpenAPI document: 1.0.0
Contact: contact@crowdsec.net

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Decision } from '../models';
// @ts-ignore
import { DecisionsStreamResponse } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * BouncersApi - axios parameter creator
 * @export
 */
export const BouncersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary getDecisionsStream
         * @param {boolean} [startup] If true, means that the bouncers is starting and a full list must be provided
         * @param {string} [scopes] Comma separated scopes of decisions to fetch
         * @param {string} [origins] Comma separated name of origins. If provided, then only the decisions originating from provided origins would be returned.
         * @param {string} [scenariosContaining] Comma separated words. If provided, only the decisions created by scenarios containing any of the provided word would be returned.
         * @param {string} [scenariosNotContaining] Comma separated words. If provided, only the decisions created by scenarios, not containing any of the provided word would be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecisionsStream: async (startup?: boolean, scopes?: string, origins?: string, scenariosContaining?: string, scenariosNotContaining?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Api-Key", keyParamName: "aPIKeyAuthorizer", configuration })
            if (startup !== undefined) {
                localVarQueryParameter['startup'] = startup;
            }

            if (scopes !== undefined) {
                localVarQueryParameter['scopes'] = scopes;
            }

            if (origins !== undefined) {
                localVarQueryParameter['origins'] = origins;
            }

            if (scenariosContaining !== undefined) {
                localVarQueryParameter['scenarios_containing'] = scenariosContaining;
            }

            if (scenariosNotContaining !== undefined) {
                localVarQueryParameter['scenarios_not_containing'] = scenariosNotContaining;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions/stream',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary GetDecisionsStream
         * @param {boolean} [startup] If true, means that the bouncer is starting and a full list must be provided
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecisionsStream_1: async (startup?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Api-Key", keyParamName: "aPIKeyAuthorizer", configuration })
            if (startup !== undefined) {
                localVarQueryParameter['startup'] = startup;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions/stream',
                httpMethod: 'HEAD'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about existing decisions
         * @summary getDecisions
         * @param {string} [scope] scope to which the decision applies (ie. IP/Range/Username/Session/...)
         * @param {string} [value] the value to match for in the specified scope
         * @param {string} [type] type of decision
         * @param {string} [ip] IP to search for (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] range to search for (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {boolean} [contains] indicate if you\&#39;re looking for a decision that contains the value, or that is contained within the value
         * @param {string} [origins] Comma separated name of origins. If provided, then only the decisions originating from provided origins would be returned.
         * @param {string} [scenariosContaining] Comma separated words. If provided, only the decisions created by scenarios containing any of the provided word would be returned.
         * @param {string} [scenariosNotContaining] Comma separated words. If provided, only the decisions created by scenarios, not containing any of the provided word would be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation: async (scope?: string, value?: string, type?: string, ip?: string, range?: string, contains?: boolean, origins?: string, scenariosContaining?: string, scenariosNotContaining?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (origins !== undefined) {
                localVarQueryParameter['origins'] = origins;
            }

            if (scenariosContaining !== undefined) {
                localVarQueryParameter['scenarios_containing'] = scenariosContaining;
            }

            if (scenariosNotContaining !== undefined) {
                localVarQueryParameter['scenarios_not_containing'] = scenariosNotContaining;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about existing decisions
         * @summary GetDecisions
         * @param {string} [scope] scope to which the decision applies (ie. IP/Range/Username/Session/...)
         * @param {string} [value] the value to match for in the specified scope
         * @param {string} [type] type of decision
         * @param {string} [ip] IP to search for (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] range to search for (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {boolean} [contains] indicate if you\&#39;re looking for a decision that contains the value, or that is contained within the value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation_2: async (scope?: string, value?: string, type?: string, ip?: string, range?: string, contains?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "X-Api-Key", keyParamName: "aPIKeyAuthorizer", configuration })
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions',
                httpMethod: 'HEAD'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BouncersApi - functional programming interface
 * @export
 */
export const BouncersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BouncersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary getDecisionsStream
         * @param {BouncersApiGetDecisionsStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDecisionsStream(requestParameters: BouncersApiGetDecisionsStreamRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DecisionsStreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDecisionsStream(requestParameters.startup, requestParameters.scopes, requestParameters.origins, requestParameters.scenariosContaining, requestParameters.scenariosNotContaining, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary GetDecisionsStream
         * @param {BouncersApiGetDecisionsStream0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDecisionsStream_1(requestParameters: BouncersApiGetDecisionsStream0Request = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDecisionsStream_1(requestParameters.startup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about existing decisions
         * @summary getDecisions
         * @param {BouncersApiGetInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformation(requestParameters: BouncersApiGetInformationRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Decision>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformation(requestParameters.scope, requestParameters.value, requestParameters.type, requestParameters.ip, requestParameters.range, requestParameters.contains, requestParameters.origins, requestParameters.scenariosContaining, requestParameters.scenariosNotContaining, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about existing decisions
         * @summary GetDecisions
         * @param {BouncersApiGetInformation0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInformation_2(requestParameters: BouncersApiGetInformation0Request = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInformation_2(requestParameters.scope, requestParameters.value, requestParameters.type, requestParameters.ip, requestParameters.range, requestParameters.contains, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BouncersApi - factory interface
 * @export
 */
export const BouncersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BouncersApiFp(configuration)
    return {
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary getDecisionsStream
         * @param {BouncersApiGetDecisionsStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecisionsStream(requestParameters: BouncersApiGetDecisionsStreamRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DecisionsStreamResponse> {
            return localVarFp.getDecisionsStream(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
         * @summary GetDecisionsStream
         * @param {BouncersApiGetDecisionsStream0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDecisionsStream_1(requestParameters: BouncersApiGetDecisionsStream0Request = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDecisionsStream_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about existing decisions
         * @summary getDecisions
         * @param {BouncersApiGetInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation(requestParameters: BouncersApiGetInformationRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Decision>> {
            return localVarFp.getInformation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about existing decisions
         * @summary GetDecisions
         * @param {BouncersApiGetInformation0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInformation_2(requestParameters: BouncersApiGetInformation0Request = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getInformation_2(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDecisionsStream operation in BouncersApi.
 * @export
 * @interface BouncersApiGetDecisionsStreamRequest
 */
export type BouncersApiGetDecisionsStreamRequest = {
    
    /**
    * If true, means that the bouncers is starting and a full list must be provided
    * @type {boolean}
    * @memberof BouncersApiGetDecisionsStream
    */
    readonly startup?: boolean
    
    /**
    * Comma separated scopes of decisions to fetch
    * @type {string}
    * @memberof BouncersApiGetDecisionsStream
    */
    readonly scopes?: string
    
    /**
    * Comma separated name of origins. If provided, then only the decisions originating from provided origins would be returned.
    * @type {string}
    * @memberof BouncersApiGetDecisionsStream
    */
    readonly origins?: string
    
    /**
    * Comma separated words. If provided, only the decisions created by scenarios containing any of the provided word would be returned.
    * @type {string}
    * @memberof BouncersApiGetDecisionsStream
    */
    readonly scenariosContaining?: string
    
    /**
    * Comma separated words. If provided, only the decisions created by scenarios, not containing any of the provided word would be returned.
    * @type {string}
    * @memberof BouncersApiGetDecisionsStream
    */
    readonly scenariosNotContaining?: string
    
}

/**
 * Request parameters for getDecisionsStream_1 operation in BouncersApi.
 * @export
 * @interface BouncersApiGetDecisionsStream0Request
 */
export type BouncersApiGetDecisionsStream0Request = {
    
    /**
    * If true, means that the bouncer is starting and a full list must be provided
    * @type {boolean}
    * @memberof BouncersApiGetDecisionsStream0
    */
    readonly startup?: boolean
    
}

/**
 * Request parameters for getInformation operation in BouncersApi.
 * @export
 * @interface BouncersApiGetInformationRequest
 */
export type BouncersApiGetInformationRequest = {
    
    /**
    * scope to which the decision applies (ie. IP/Range/Username/Session/...)
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly scope?: string
    
    /**
    * the value to match for in the specified scope
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly value?: string
    
    /**
    * type of decision
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly type?: string
    
    /**
    * IP to search for (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly ip?: string
    
    /**
    * range to search for (shorthand for scope=range&value=)
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly range?: string
    
    /**
    * indicate if you\'re looking for a decision that contains the value, or that is contained within the value
    * @type {boolean}
    * @memberof BouncersApiGetInformation
    */
    readonly contains?: boolean
    
    /**
    * Comma separated name of origins. If provided, then only the decisions originating from provided origins would be returned.
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly origins?: string
    
    /**
    * Comma separated words. If provided, only the decisions created by scenarios containing any of the provided word would be returned.
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly scenariosContaining?: string
    
    /**
    * Comma separated words. If provided, only the decisions created by scenarios, not containing any of the provided word would be returned.
    * @type {string}
    * @memberof BouncersApiGetInformation
    */
    readonly scenariosNotContaining?: string
    
}

/**
 * Request parameters for getInformation_2 operation in BouncersApi.
 * @export
 * @interface BouncersApiGetInformation0Request
 */
export type BouncersApiGetInformation0Request = {
    
    /**
    * scope to which the decision applies (ie. IP/Range/Username/Session/...)
    * @type {string}
    * @memberof BouncersApiGetInformation0
    */
    readonly scope?: string
    
    /**
    * the value to match for in the specified scope
    * @type {string}
    * @memberof BouncersApiGetInformation0
    */
    readonly value?: string
    
    /**
    * type of decision
    * @type {string}
    * @memberof BouncersApiGetInformation0
    */
    readonly type?: string
    
    /**
    * IP to search for (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof BouncersApiGetInformation0
    */
    readonly ip?: string
    
    /**
    * range to search for (shorthand for scope=range&value=)
    * @type {string}
    * @memberof BouncersApiGetInformation0
    */
    readonly range?: string
    
    /**
    * indicate if you\'re looking for a decision that contains the value, or that is contained within the value
    * @type {boolean}
    * @memberof BouncersApiGetInformation0
    */
    readonly contains?: boolean
    
}

/**
 * BouncersApiGenerated - object-oriented interface
 * @export
 * @class BouncersApiGenerated
 * @extends {BaseAPI}
 */
export class BouncersApiGenerated extends BaseAPI {
    /**
     * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
     * @summary getDecisionsStream
     * @param {BouncersApiGetDecisionsStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BouncersApiGenerated
     */
    public getDecisionsStream(requestParameters: BouncersApiGetDecisionsStreamRequest = {}, options?: AxiosRequestConfig) {
        return BouncersApiFp(this.configuration).getDecisionsStream(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of new/expired decisions. Intended for bouncers that need to \"stream\" decisions
     * @summary GetDecisionsStream
     * @param {BouncersApiGetDecisionsStream0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BouncersApiGenerated
     */
    public getDecisionsStream_1(requestParameters: BouncersApiGetDecisionsStream0Request = {}, options?: AxiosRequestConfig) {
        return BouncersApiFp(this.configuration).getDecisionsStream_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about existing decisions
     * @summary getDecisions
     * @param {BouncersApiGetInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BouncersApiGenerated
     */
    public getInformation(requestParameters: BouncersApiGetInformationRequest = {}, options?: AxiosRequestConfig) {
        return BouncersApiFp(this.configuration).getInformation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about existing decisions
     * @summary GetDecisions
     * @param {BouncersApiGetInformation0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BouncersApiGenerated
     */
    public getInformation_2(requestParameters: BouncersApiGetInformation0Request = {}, options?: AxiosRequestConfig) {
        return BouncersApiFp(this.configuration).getInformation_2(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
