/* tslint:disable */
/* eslint-disable */
/*
Swagger CrowdSec

CrowdSec local API

The version of the OpenAPI document: 1.0.0
Contact: contact@crowdsec.net

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Alert } from '../models';
// @ts-ignore
import { DeleteAlertsResponse } from '../models';
// @ts-ignore
import { DeleteDecisionResponse } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { WatcherAuthRequest } from '../models';
// @ts-ignore
import { WatcherAuthResponse } from '../models';
// @ts-ignore
import { WatcherRegistrationRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * WatchersApi - axios parameter creator
 * @export
 */
export const WatchersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate current to get session ID
         * @summary AuthenticateWatcher
         * @param {WatcherAuthRequest} watcherAuthRequest Information about the watcher to be reset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSession: async (watcherAuthRequest: WatcherAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherAuthRequest' is not null or undefined
            assertParamExists('authenticateSession', 'watcherAuthRequest', watcherAuthRequest)
            const localVarPath = `/watchers/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: watcherAuthRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/watchers/login',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(watcherAuthRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Push alerts to API
         * @summary pushAlerts
         * @param {Array<Alert>} alert Push alerts to the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlerts: async (alert: Array<Alert>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alert' is not null or undefined
            assertParamExists('createAlerts', 'alert', alert)
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: alert,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(alert, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alert for given alert ID (only from cscli)
         * @summary DeleteAlert
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertById: async (alertId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlertById', 'alertId', alertId)
            const localVarPath = `/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId !== undefined ? alertId : `-alert_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts/{alert_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertById: async (alertId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertById', 'alertId', alertId)
            const localVarPath = `/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId !== undefined ? alertId : `-alert_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts/{alert_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertById_1: async (alertId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertById_1', 'alertId', alertId)
            const localVarPath = `/alerts/{alert_id}`
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId !== undefined ? alertId : `-alert_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts/{alert_id}',
                httpMethod: 'HEAD'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {string} [scope] show alerts for this scope
         * @param {string} [value] show alerts for this value (used with scope)
         * @param {string} [scenario] show alerts for this scenario
         * @param {string} [ip] IP to search for (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] range to search for (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {string} [since] search alerts newer than delay (format must be compatible with time.ParseDuration)
         * @param {string} [until] search alerts older than delay (format must be compatible with time.ParseDuration)
         * @param {boolean} [simulated] if set to true, decisions in simulation mode will be returned as well
         * @param {boolean} [hasActiveDecision] only return alerts with decisions not expired yet
         * @param {string} [decisionType] restrict results to alerts with decisions matching given type
         * @param {number} [limit] number of alerts to return
         * @param {string} [origin] restrict results to this origin (ie. lists,CAPI,cscli)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (scope?: string, value?: string, scenario?: string, ip?: string, range?: string, since?: string, until?: string, simulated?: boolean, hasActiveDecision?: boolean, decisionType?: string, limit?: number, origin?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString() :
                    until;
            }

            if (simulated !== undefined) {
                localVarQueryParameter['simulated'] = simulated;
            }

            if (hasActiveDecision !== undefined) {
                localVarQueryParameter['has_active_decision'] = hasActiveDecision;
            }

            if (decisionType !== undefined) {
                localVarQueryParameter['decision_type'] = decisionType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is used when installing crowdsec (cscli->APIL)
         * @summary RegisterWatcher
         * @param {WatcherRegistrationRequest} watcherRegistrationRequest Information about the watcher to be registered
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWatcher: async (watcherRegistrationRequest: WatcherRegistrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watcherRegistrationRequest' is not null or undefined
            assertParamExists('registerWatcher', 'watcherRegistrationRequest', watcherRegistrationRequest)
            const localVarPath = `/watchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: watcherRegistrationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/watchers',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(watcherRegistrationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to delete alerts
         * @summary deleteAlerts
         * @param {string} [scope] delete alerts for this scope
         * @param {string} [value] delete alerts for this value (used with scope)
         * @param {string} [scenario] delete alerts for this scenario
         * @param {string} [ip] delete Alerts with IP (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] delete alerts concerned by range (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {string} [since] delete alerts added after YYYY-mm-DD-HH:MM:SS
         * @param {string} [until] delete alerts added before YYYY-mm-DD-HH:MM:SS
         * @param {boolean} [hasActiveDecision] delete only alerts with decisions not expired yet
         * @param {string} [alertSource] delete only alerts with matching source (ie. cscli/crowdsec)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAlerts: async (scope?: string, value?: string, scenario?: string, ip?: string, range?: string, since?: string, until?: string, hasActiveDecision?: boolean, alertSource?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString() :
                    until;
            }

            if (hasActiveDecision !== undefined) {
                localVarQueryParameter['has_active_decision'] = hasActiveDecision;
            }

            if (alertSource !== undefined) {
                localVarQueryParameter['alert_source'] = alertSource;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete decision for given decision ID (only from cscli)
         * @summary DeleteDecision
         * @param {string} decisionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDecisionById: async (decisionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'decisionId' is not null or undefined
            assertParamExists('removeDecisionById', 'decisionId', decisionId)
            const localVarPath = `/decisions/{decision_id}`
                .replace(`{${"decision_id"}}`, encodeURIComponent(String(decisionId !== undefined ? decisionId : `-decision_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions/{decision_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete decisions(s) for given filters (only from cscli)
         * @summary deleteDecisions
         * @param {string} [scope] scope to which the decision applies (ie. IP/Range/Username/Session/...)
         * @param {string} [value] the value to match for in the specified scope
         * @param {string} [type] type of decision
         * @param {string} [ip] IP to search for (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] range to search for (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {string} [scenario] scenario to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDecisions: async (scope?: string, value?: string, type?: string, ip?: string, range?: string, scenario?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/decisions',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {string} [scope] show alerts for this scope
         * @param {string} [value] show alerts for this value (used with scope)
         * @param {string} [scenario] show alerts for this scenario
         * @param {string} [ip] IP to search for (shorthand for scope&#x3D;ip&amp;value&#x3D;)
         * @param {string} [range] range to search for (shorthand for scope&#x3D;range&amp;value&#x3D;)
         * @param {string} [since] search alerts newer than delay (format must be compatible with time.ParseDuration)
         * @param {string} [until] search alerts older than delay (format must be compatible with time.ParseDuration)
         * @param {boolean} [simulated] if set to true, decisions in simulation mode will be returned as well
         * @param {boolean} [hasActiveDecision] only return alerts with decisions not expired yet
         * @param {string} [decisionType] restrict results to alerts with decisions matching given type
         * @param {number} [limit] number of alerts to return
         * @param {string} [origin] restrict results to this origin (ie. lists,CAPI,cscli)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAlerts: async (scope?: string, value?: string, scenario?: string, ip?: string, range?: string, since?: string, until?: string, simulated?: boolean, hasActiveDecision?: boolean, decisionType?: string, limit?: number, origin?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTAuthorizer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization: Bearer", keyParamName: "jWTAuthorizer", configuration })
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (scenario !== undefined) {
                localVarQueryParameter['scenario'] = scenario;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString() :
                    until;
            }

            if (simulated !== undefined) {
                localVarQueryParameter['simulated'] = simulated;
            }

            if (hasActiveDecision !== undefined) {
                localVarQueryParameter['has_active_decision'] = hasActiveDecision;
            }

            if (decisionType !== undefined) {
                localVarQueryParameter['decision_type'] = decisionType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/alerts',
                httpMethod: 'HEAD'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchersApi - functional programming interface
 * @export
 */
export const WatchersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchersApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate current to get session ID
         * @summary AuthenticateWatcher
         * @param {WatchersApiAuthenticateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateSession(requestParameters: WatchersApiAuthenticateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatcherAuthResponse>> {
            const watcherAuthRequest: WatcherAuthRequest = {
                machine_id: requestParameters.machine_id,
                password: requestParameters.password,
                scenarios: requestParameters.scenarios
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateSession(watcherAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Push alerts to API
         * @summary pushAlerts
         * @param {WatchersApiCreateAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlerts(requestParameters: WatchersApiCreateAlertsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const alert: Array<Alert> = requestParameters;
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlerts(alert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete alert for given alert ID (only from cscli)
         * @summary DeleteAlert
         * @param {WatchersApiDeleteAlertByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertById(requestParameters: WatchersApiDeleteAlertByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertById(requestParameters.alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {WatchersApiGetAlertByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertById(requestParameters: WatchersApiGetAlertByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertById(requestParameters.alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {WatchersApiGetAlertById0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertById_1(requestParameters: WatchersApiGetAlertById0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertById_1(requestParameters.alertId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {WatchersApiListAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(requestParameters: WatchersApiListAlertsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alert>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(requestParameters.scope, requestParameters.value, requestParameters.scenario, requestParameters.ip, requestParameters.range, requestParameters.since, requestParameters.until, requestParameters.simulated, requestParameters.hasActiveDecision, requestParameters.decisionType, requestParameters.limit, requestParameters.origin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method is used when installing crowdsec (cscli->APIL)
         * @summary RegisterWatcher
         * @param {WatchersApiRegisterWatcherRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerWatcher(requestParameters: WatchersApiRegisterWatcherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const watcherRegistrationRequest: WatcherRegistrationRequest = {
                machine_id: requestParameters.machine_id,
                password: requestParameters.password
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerWatcher(watcherRegistrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows to delete alerts
         * @summary deleteAlerts
         * @param {WatchersApiRemoveAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAlerts(requestParameters: WatchersApiRemoveAlertsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAlerts(requestParameters.scope, requestParameters.value, requestParameters.scenario, requestParameters.ip, requestParameters.range, requestParameters.since, requestParameters.until, requestParameters.hasActiveDecision, requestParameters.alertSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete decision for given decision ID (only from cscli)
         * @summary DeleteDecision
         * @param {WatchersApiRemoveDecisionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDecisionById(requestParameters: WatchersApiRemoveDecisionByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDecisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDecisionById(requestParameters.decisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete decisions(s) for given filters (only from cscli)
         * @summary deleteDecisions
         * @param {WatchersApiRemoveDecisionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDecisions(requestParameters: WatchersApiRemoveDecisionsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDecisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDecisions(requestParameters.scope, requestParameters.value, requestParameters.type, requestParameters.ip, requestParameters.range, requestParameters.scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {WatchersApiSearchAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAlerts(requestParameters: WatchersApiSearchAlertsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAlerts(requestParameters.scope, requestParameters.value, requestParameters.scenario, requestParameters.ip, requestParameters.range, requestParameters.since, requestParameters.until, requestParameters.simulated, requestParameters.hasActiveDecision, requestParameters.decisionType, requestParameters.limit, requestParameters.origin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WatchersApi - factory interface
 * @export
 */
export const WatchersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchersApiFp(configuration)
    return {
        /**
         * Authenticate current to get session ID
         * @summary AuthenticateWatcher
         * @param {WatchersApiAuthenticateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSession(requestParameters: WatchersApiAuthenticateSessionRequest, options?: AxiosRequestConfig): AxiosPromise<WatcherAuthResponse> {
            return localVarFp.authenticateSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Push alerts to API
         * @summary pushAlerts
         * @param {WatchersApiCreateAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlerts(requestParameters: WatchersApiCreateAlertsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createAlerts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alert for given alert ID (only from cscli)
         * @summary DeleteAlert
         * @param {WatchersApiDeleteAlertByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertById(requestParameters: WatchersApiDeleteAlertByIdRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteAlertsResponse> {
            return localVarFp.deleteAlertById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {WatchersApiGetAlertByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertById(requestParameters: WatchersApiGetAlertByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Alert> {
            return localVarFp.getAlertById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alert by ID
         * @summary GetAlertByID
         * @param {WatchersApiGetAlertById0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertById_1(requestParameters: WatchersApiGetAlertById0Request, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAlertById_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {WatchersApiListAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(requestParameters: WatchersApiListAlertsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Alert>> {
            return localVarFp.listAlerts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is used when installing crowdsec (cscli->APIL)
         * @summary RegisterWatcher
         * @param {WatchersApiRegisterWatcherRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWatcher(requestParameters: WatchersApiRegisterWatcherRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.registerWatcher(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to delete alerts
         * @summary deleteAlerts
         * @param {WatchersApiRemoveAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAlerts(requestParameters: WatchersApiRemoveAlertsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DeleteAlertsResponse> {
            return localVarFp.removeAlerts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete decision for given decision ID (only from cscli)
         * @summary DeleteDecision
         * @param {WatchersApiRemoveDecisionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDecisionById(requestParameters: WatchersApiRemoveDecisionByIdRequest, options?: AxiosRequestConfig): AxiosPromise<DeleteDecisionResponse> {
            return localVarFp.removeDecisionById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete decisions(s) for given filters (only from cscli)
         * @summary deleteDecisions
         * @param {WatchersApiRemoveDecisionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDecisions(requestParameters: WatchersApiRemoveDecisionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DeleteDecisionResponse> {
            return localVarFp.removeDecisions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to search for alerts
         * @summary searchAlerts
         * @param {WatchersApiSearchAlertsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAlerts(requestParameters: WatchersApiSearchAlertsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchAlerts(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticateSession operation in WatchersApi.
 * @export
 * @interface WatchersApiAuthenticateSessionRequest
 */
export type WatchersApiAuthenticateSessionRequest = {
    
} & WatcherAuthRequest

/**
 * Request parameters for createAlerts operation in WatchersApi.
 * @export
 * @interface WatchersApiCreateAlertsRequest
 */
export type WatchersApiCreateAlertsRequest = Array<Alert>

/**
 * Request parameters for deleteAlertById operation in WatchersApi.
 * @export
 * @interface WatchersApiDeleteAlertByIdRequest
 */
export type WatchersApiDeleteAlertByIdRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof WatchersApiDeleteAlertById
    */
    readonly alertId: string
    
}

/**
 * Request parameters for getAlertById operation in WatchersApi.
 * @export
 * @interface WatchersApiGetAlertByIdRequest
 */
export type WatchersApiGetAlertByIdRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof WatchersApiGetAlertById
    */
    readonly alertId: string
    
}

/**
 * Request parameters for getAlertById_1 operation in WatchersApi.
 * @export
 * @interface WatchersApiGetAlertById0Request
 */
export type WatchersApiGetAlertById0Request = {
    
    /**
    * 
    * @type {string}
    * @memberof WatchersApiGetAlertById0
    */
    readonly alertId: string
    
}

/**
 * Request parameters for listAlerts operation in WatchersApi.
 * @export
 * @interface WatchersApiListAlertsRequest
 */
export type WatchersApiListAlertsRequest = {
    
    /**
    * show alerts for this scope
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly scope?: string
    
    /**
    * show alerts for this value (used with scope)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly value?: string
    
    /**
    * show alerts for this scenario
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly scenario?: string
    
    /**
    * IP to search for (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly ip?: string
    
    /**
    * range to search for (shorthand for scope=range&value=)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly range?: string
    
    /**
    * search alerts newer than delay (format must be compatible with time.ParseDuration)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly since?: string
    
    /**
    * search alerts older than delay (format must be compatible with time.ParseDuration)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly until?: string
    
    /**
    * if set to true, decisions in simulation mode will be returned as well
    * @type {boolean}
    * @memberof WatchersApiListAlerts
    */
    readonly simulated?: boolean
    
    /**
    * only return alerts with decisions not expired yet
    * @type {boolean}
    * @memberof WatchersApiListAlerts
    */
    readonly hasActiveDecision?: boolean
    
    /**
    * restrict results to alerts with decisions matching given type
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly decisionType?: string
    
    /**
    * number of alerts to return
    * @type {number}
    * @memberof WatchersApiListAlerts
    */
    readonly limit?: number
    
    /**
    * restrict results to this origin (ie. lists,CAPI,cscli)
    * @type {string}
    * @memberof WatchersApiListAlerts
    */
    readonly origin?: string
    
}

/**
 * Request parameters for registerWatcher operation in WatchersApi.
 * @export
 * @interface WatchersApiRegisterWatcherRequest
 */
export type WatchersApiRegisterWatcherRequest = {
    
} & WatcherRegistrationRequest

/**
 * Request parameters for removeAlerts operation in WatchersApi.
 * @export
 * @interface WatchersApiRemoveAlertsRequest
 */
export type WatchersApiRemoveAlertsRequest = {
    
    /**
    * delete alerts for this scope
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly scope?: string
    
    /**
    * delete alerts for this value (used with scope)
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly value?: string
    
    /**
    * delete alerts for this scenario
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly scenario?: string
    
    /**
    * delete Alerts with IP (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly ip?: string
    
    /**
    * delete alerts concerned by range (shorthand for scope=range&value=)
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly range?: string
    
    /**
    * delete alerts added after YYYY-mm-DD-HH:MM:SS
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly since?: string
    
    /**
    * delete alerts added before YYYY-mm-DD-HH:MM:SS
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly until?: string
    
    /**
    * delete only alerts with decisions not expired yet
    * @type {boolean}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly hasActiveDecision?: boolean
    
    /**
    * delete only alerts with matching source (ie. cscli/crowdsec)
    * @type {string}
    * @memberof WatchersApiRemoveAlerts
    */
    readonly alertSource?: string
    
}

/**
 * Request parameters for removeDecisionById operation in WatchersApi.
 * @export
 * @interface WatchersApiRemoveDecisionByIdRequest
 */
export type WatchersApiRemoveDecisionByIdRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof WatchersApiRemoveDecisionById
    */
    readonly decisionId: string
    
}

/**
 * Request parameters for removeDecisions operation in WatchersApi.
 * @export
 * @interface WatchersApiRemoveDecisionsRequest
 */
export type WatchersApiRemoveDecisionsRequest = {
    
    /**
    * scope to which the decision applies (ie. IP/Range/Username/Session/...)
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly scope?: string
    
    /**
    * the value to match for in the specified scope
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly value?: string
    
    /**
    * type of decision
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly type?: string
    
    /**
    * IP to search for (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly ip?: string
    
    /**
    * range to search for (shorthand for scope=range&value=)
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly range?: string
    
    /**
    * scenario to search
    * @type {string}
    * @memberof WatchersApiRemoveDecisions
    */
    readonly scenario?: string
    
}

/**
 * Request parameters for searchAlerts operation in WatchersApi.
 * @export
 * @interface WatchersApiSearchAlertsRequest
 */
export type WatchersApiSearchAlertsRequest = {
    
    /**
    * show alerts for this scope
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly scope?: string
    
    /**
    * show alerts for this value (used with scope)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly value?: string
    
    /**
    * show alerts for this scenario
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly scenario?: string
    
    /**
    * IP to search for (shorthand for scope=ip&value=)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly ip?: string
    
    /**
    * range to search for (shorthand for scope=range&value=)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly range?: string
    
    /**
    * search alerts newer than delay (format must be compatible with time.ParseDuration)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly since?: string
    
    /**
    * search alerts older than delay (format must be compatible with time.ParseDuration)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly until?: string
    
    /**
    * if set to true, decisions in simulation mode will be returned as well
    * @type {boolean}
    * @memberof WatchersApiSearchAlerts
    */
    readonly simulated?: boolean
    
    /**
    * only return alerts with decisions not expired yet
    * @type {boolean}
    * @memberof WatchersApiSearchAlerts
    */
    readonly hasActiveDecision?: boolean
    
    /**
    * restrict results to alerts with decisions matching given type
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly decisionType?: string
    
    /**
    * number of alerts to return
    * @type {number}
    * @memberof WatchersApiSearchAlerts
    */
    readonly limit?: number
    
    /**
    * restrict results to this origin (ie. lists,CAPI,cscli)
    * @type {string}
    * @memberof WatchersApiSearchAlerts
    */
    readonly origin?: string
    
}

/**
 * WatchersApiGenerated - object-oriented interface
 * @export
 * @class WatchersApiGenerated
 * @extends {BaseAPI}
 */
export class WatchersApiGenerated extends BaseAPI {
    /**
     * Authenticate current to get session ID
     * @summary AuthenticateWatcher
     * @param {WatchersApiAuthenticateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public authenticateSession(requestParameters: WatchersApiAuthenticateSessionRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).authenticateSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Push alerts to API
     * @summary pushAlerts
     * @param {WatchersApiCreateAlertsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public createAlerts(requestParameters: WatchersApiCreateAlertsRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).createAlerts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alert for given alert ID (only from cscli)
     * @summary DeleteAlert
     * @param {WatchersApiDeleteAlertByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public deleteAlertById(requestParameters: WatchersApiDeleteAlertByIdRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).deleteAlertById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alert by ID
     * @summary GetAlertByID
     * @param {WatchersApiGetAlertByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public getAlertById(requestParameters: WatchersApiGetAlertByIdRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).getAlertById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alert by ID
     * @summary GetAlertByID
     * @param {WatchersApiGetAlertById0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public getAlertById_1(requestParameters: WatchersApiGetAlertById0Request, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).getAlertById_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to search for alerts
     * @summary searchAlerts
     * @param {WatchersApiListAlertsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public listAlerts(requestParameters: WatchersApiListAlertsRequest = {}, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).listAlerts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is used when installing crowdsec (cscli->APIL)
     * @summary RegisterWatcher
     * @param {WatchersApiRegisterWatcherRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public registerWatcher(requestParameters: WatchersApiRegisterWatcherRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).registerWatcher(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to delete alerts
     * @summary deleteAlerts
     * @param {WatchersApiRemoveAlertsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public removeAlerts(requestParameters: WatchersApiRemoveAlertsRequest = {}, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).removeAlerts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete decision for given decision ID (only from cscli)
     * @summary DeleteDecision
     * @param {WatchersApiRemoveDecisionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public removeDecisionById(requestParameters: WatchersApiRemoveDecisionByIdRequest, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).removeDecisionById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete decisions(s) for given filters (only from cscli)
     * @summary deleteDecisions
     * @param {WatchersApiRemoveDecisionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public removeDecisions(requestParameters: WatchersApiRemoveDecisionsRequest = {}, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).removeDecisions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to search for alerts
     * @summary searchAlerts
     * @param {WatchersApiSearchAlertsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchersApiGenerated
     */
    public searchAlerts(requestParameters: WatchersApiSearchAlertsRequest = {}, options?: AxiosRequestConfig) {
        return WatchersApiFp(this.configuration).searchAlerts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
